# -*- coding: utf-8 -*-
"""Mech344PythPro.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bkST9zKsRb5tISd0JRZqFjKTLUZZF0E-

Code For Wednesday 3/20/24
EX:
3x4 grid insulated on bottom
top and right 100 C
final left three points 0 C
Find 3 Middle Points

# Math

Knowns\
T1 = T2 = T3 = T6 = T9 = T12 = 100\
T4 = T7 = T10 = 0

\
4*T5 = (T2+T8+T4+T6) (EQ1)

4*T8 = (T5+T7+T9+T11) (EQ2)

4*T11  = (2*T8+T10+T12) (EQ3)


Solved

4*T5-T8+0*T11 = T2+T6 (EQ1)

-T5+4*T8-T11 = T7+T9 (EQ2)

0*T5-2*T8+4T11 = T10+T12 (EQ3)

matrix

A*B = C

[T5;T8;T11]*[4,-1,0;-1,4,-1;0,-2,4] = [200,100,100]

A = C\B
"""

import numpy as np

T1 = T2 = T3 = T6 = T9 = T12 = 100
T4 = T7 = T10 = 0

MatB = np.array([[4,-1,0],[-1,4,-1],[0,-2,4]])
MatC = np.array([[T2+T6],[T7+T9],[T10+T12]])

MatBi = np.linalg.inv(MatB)

MatA = np.matmul(MatBi,MatC)

print(MatA)

#Solved for 3 internal points

import numpy as np

T1 = T2 = T3 = T6 = T9 = T12 = 100
T4 = T7 = T10 = 0

MatB = np.array([[4,-1,0],[-1,4,-1],[0,-2,4]])
MatC = np.array([[T2+T6],[T7+T9],[T10+T12]])

MatBi = np.linalg.inv(MatB)

MatA = np.matmul(MatBi,MatC)

T5 = MatA[0,0]
T8 = MatA[1,0]
T11 = MatA[2,0]

print("T5 =",T5)
print("T8 =",T8)
print("T11 =",T11)

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from matplotlib.animation import FuncAnimation
import warnings
warnings.filterwarnings('ignore', category=DeprecationWarning)


print("2D Hear Equation Small Example")
print("")

Nx = 3
Ny = 4

x_plate_length = 0.2
y_plate_length = 0.3
dx = x_plate_length/(Nx-1)
dy = y_plate_length/(Ny-1)

k = 25.0

#initialize solution grid u(k,i,j) k = time index i= rows j=number of columns
u = np.empty((Ny,Nx))
print(u)
print("")
#boundry conditions
u_top = 100
u_left = 0
u_right = 100

#Set the boundy condidtions
for i in range(0, Ny,1):
  u[i, 0] = u_left
print(u)
print("")
for j in range(0, Ny-1,1):
  u[0, j] = u_right
print(u)
print("")
for i in range(0, Ny,1):
  u[i, Nx-1] = u_top
print(u)
print("")


#order of for loop important to set top corner 100(last 4 loop)

a = np.array([[4,-1,0],[-1,4,-1],[0,-2,4]])
b = [u[1,0]+u[0,1]+u[1,2]],[u[2,0]+u[2,2]],[u[3,0]+u[3,2]]
print(b)
print("")

x = np.linalg.solve(a, b)
print(x)
print("")

u[1,1] = x[0]
u[2,1] = x[1]
u[3,1] = x[2]

print(u)
print("")

im = plt.imshow(u[:,:],cmap=plt.cm.RdBu)

cset = plt.contour(u[:,:],np.arange(10,100,10),linewidths=2,cmap=plt.cm.Set2)
plt.clabel(cset,inline=True,fmt='%1.2f',fontsize=10)
plt.colorbar(im)

plt.title(f'$u(x,y)$')
plt.show()

"""In class code"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from matplotlib.animation import FuncAnimation

print("2D Hear Equation Small Example")

Nx = 3
Ny = 4

x_plate_length = 0.2
y_plate_length = 0.3
dx = x_plate_length/(Nx-1)
dy = y_plate_length/(Ny-1)

k = 25.0

#initialize solution grid u(k,i,j) k = time index i= rows j=number of columns
u = np.empty((Nx,Ny))



print("The Shapeof u is: ",u.shape)

#boundry conditions
u_top = 100
u_left = 0
u_right = 100

#Set the boundy condidtions
for j in range(0, Ny-1,1):
  u[0, j] = u_left
for j in range(0, Ny-1,1):
  u[Nx-1, j] = u_right
for i in range(0, Nx-1,1):
  u[i, Ny-1] = u_top

print(u)
#order of for loop important to set top corner 100(last 4 loop)

def calculate():
  a = np.array([[4,-1,0],[-1,4,-1],[0,-2,4]])
  b = np.array([[u[1,3]+u[0,2]+u[2,2]],[u[0,1]+u[2,1]],[u[0,0]+u[2,0]]])
  x = np.linalg.solve(a, b)
  print(x)
  u[1,0] = x[2]
  u[1,1] = x[1]
  u[1,2] = x[0]
  return u
u  = calculate()

print(u)

im = plt.imshow(u[:,:],cmap=plt.cm.RdBu)

cset = plt.contour(u[:,:],np.arange(10,100,10),linewidths=2,cmap=plt.cm.Set2)
plt.clabel(cset,inline=True,fmt='%1.2f',fontsize=10)
plt.colorbar(im)

plt.title(f'$u(x,y)$')
plt.show()

"""# *Project* problem 1

left 30 C

right 70 C

5 cm tall

Ny=51

10 cm long

Nx = 101

top bottom adiabadic(ex bottom adiabadic)
"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from matplotlib.animation import FuncAnimation
import warnings
warnings.filterwarnings('ignore', category=DeprecationWarning)


print("2D Hear Equation Project Part 1")
print("")

Nx1 = 101
Ny1 = 51

x1_plate_length = 10 #cm
y1_plate_length = 5 #cm
dx1 = x1_plate_length/(Nx1-1)
dy1 = y1_plate_length/(Ny1-1)

x1 = np.linspace(0, x1_plate_length, Nx1)
y1 = np.linspace(0, y1_plate_length, Ny1)
X1, Y1 = np.meshgrid(x1, y1)

k = 25.0 #unkown

#initialize solution grid u(k,i,j) k = time index i= rows j=number of columns
l = np.ones((Ny1,Nx1))
z = 30*l
print(z)
print("")
#boundry conditions

z_right = 70 #C

#Set the boundy condidtions

for j in range(0, Ny1,1):
  z[j, Nx1-1] = z_right
print(z)
print("")

for _ in range(20000):
  new_z = np.copy(z)
  for j in range(1, Nx1-1, 1):
    for i in range(0, Ny1, 1):
      if i == 0 :
        new_z[i, j] = 0.25 * (2*z[i+1, j] + z[i, j+1] + z[i, j-1])
      elif i == Ny1-1 :
        new_z[i, j] = 0.25 * (2*z[i-1, j] + z[i, j+1] + z[i, j-1])
      else:
        new_z[i, j] = 0.25 * (z[i+1, j] + z[i-1, j] + z[i, j+1] + z[i, j-1])
  z = np.copy(new_z)

plt.figure(1)
ho = plt.contourf(X1, Y1, z, cmap='hot')
cset = plt.contour(X1,Y1,z,np.arange(10,100,10),linewidths=2,cmap='gray_r')
plt.clabel(cset,inline=True,fmt='%1.2f',fontsize=10)
plt.colorbar(ho, label='Temperature (°C)')
plt.title('Problem 1')
plt.xlabel('X (centimeters)')
plt.ylabel('Y (centimeters)')
plt.show()
print("")

plt.figure(2)
im = plt.imshow(z[:,:],cmap='hot')
bset = plt.contour(z[:,:],np.arange(10,100,10),linewidths=2,cmap='gray_r')
plt.clabel(bset,inline=True,fmt='%1.2f',fontsize=10)
plt.colorbar(im, label='Temperature (°C)')
plt.title('Problem 1')
plt.xlabel('X (Nodes)')
plt.ylabel('Y (Nodes)')
plt.show()

"""```
for _ in range(1000):
  new_z = np.copy(z)
  for j in range(1, Nx-1, 1):
    for i in range(1, Ny-1, 1):
     if i == 0 :
       new_z[i, j] = 0.25 * (2*z[i-1, j] + z[i, j+1] + z[i, j-1])
     elif i == Ny :
       new_z[i, j] = 0.25 * (2*z[i+1, j] + z[i, j+1] + z[i, j-1])
     else:
       new_z[i, j] = 0.25 * (z[i+1, j] + z[i-1, j] + z[i, j+1] + z[i, j-1])
  z = np.copy(new_z)


for _ in range(1000):
  new_z = np.copy(z)
  for j in range(1, Nx-1, 1):
    for i in range(0, Ny, 1):
     if i == 0 :
       new_z[i, j] = 50
     elif i == Ny-1 :
       new_z[i, j] = 50
     else:
       new_z[i, j] = 25
  z = np.copy(new_z)


plt.figure(figsize=(8, 6))
plt.contour(X, Y, z[:,:], cmap='hot')
plt.colorbar(im)
plt.colorbar(label='Temperature (°C)')
plt.title('$Problem 1(x,y)$')
plt.xlabel('X (centimeters)')
plt.ylabel('Y (centimeters)')
plt.show()

```

# *Project* problem 2

left 0 C

right 0 C

top middle 100 C gradient to corner 0 C

5 cm tall

Ny=501

10 cm long

Nx = 1001

bottom adiabadic(ex bottom adiabadic)
"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from matplotlib.animation import FuncAnimation
import warnings
warnings.filterwarnings('ignore', category=DeprecationWarning)


print("2D Hear Equation Project Part s")
print("")

Nx2 = 101
Ny2 = 51

x2_plate_length = 10 #cm
y2_plate_length = 5 #cm
dx2 = x2_plate_length/(Nx2-1)
dy2 = y2_plate_length/(Ny2-1)

x2 = np.linspace(0, x2_plate_length, Nx2)
y2 = np.linspace(0, y2_plate_length, Ny2)
X2, Y2 = np.meshgrid(x2, -y2)

k = 25.0 #unkown

#initialize solution grid u(k,i,j) k = time index i= rows j=number of columns
q = np.zeros((Ny2,Nx2))
print(q)
print("")

#boundry conditions

# q_top = 100 C (In center node 'gradient Temperature')

lgrad = np.linspace(0,100,51)
rgrad = np.linspace(98,0,50)

q_top = np.concatenate([lgrad,rgrad])

print(q_top.size)
print("")

#Set the boundy condidtions
for i in range(0, Nx2, 1):
  q[0, i] = q_top[i]
print(q)
print("")

for _ in range(20000):
  new_q = np.copy(q)
  for j in range(1, Nx2-1, 1):
    for i in range(1, Ny2, 1):
     if i == Ny2-1 :
       new_q[i, j] = 0.25 * (2*q[i-1, j] + q[i, j+1] + q[i, j-1])
     else:
       new_q[i, j] = 0.25 * (q[i+1, j] + q[i-1, j] + q[i, j+1] + q[i, j-1])
  q = np.copy(new_q)


print(q)
plt.figure(1)
plt.figure(figsize=(10,5))
har = plt.contourf(X2, Y2, q, cmap='hot')
aset = plt.contour(X2, Y2,q,np.arange(10,100,10),linewidths=2,cmap='gray_r')
plt.clabel(aset,inline=True,fmt='%1.2f',fontsize=10)
plt.colorbar(har, label='Temperature (°C)')
plt.title('Problem 2')
plt.xlabel('X (centimeters)')
plt.ylabel('Y (centimeters)')
plt.show()
print("")
plt.figure(figsize=(10,6))
smooth = plt.imshow(q[:,:],cmap='hot')
bzet = plt.contour(q[:,:],np.arange(10,100,10),linewidths=2,cmap='gray_r')
plt.clabel(bzet,inline=True,fmt='%1.2f',fontsize=10)
plt.colorbar(smooth)
plt.title('Problem 2')
plt.xlabel('X (Nodes)')
plt.ylabel('Y (Nodes)')
plt.show()

"""

```


plt.figure(1)
ho = plt.contourf(X2, Y2, q, cmap='hot')
cset = plt.contour(X2,Y2,q,np.arange(10,100,10),linewidths=2,cmap='gray_r')
plt.clabel(cset,inline=True,fmt='%1.2f',fontsize=10)
plt.colorbar(ho, label='Temperature (°C)')
plt.title('Problem 1')
plt.xlabel('X (centimeters)')
plt.ylabel('Y (centimeters)')
plt.show()
print("")

plt.figure(2)
im = plt.imshow(q[:,:],cmap='hot')
bset = plt.contour(q[:,:],np.arange(10,100,10),linewidths=2,cmap='gray_r')
plt.clabel(bset,inline=True,fmt='%1.2f',fontsize=10)
plt.colorbar(im)
plt.title('Problem 1')
plt.xlabel('X (Nodes)')
plt.ylabel('Y (Nodes)')
plt.show()









for i in range(0, Nx, 1):



for _ in range(1000):
  new_q = np.copy(z)
  for j in range(1, Nx-1, 1):
    for i in range(0, Ny, 1):
     if i == 0 :
       new_q[i, j] = 0.25 * (2*q[i-1, j] + q[i, j+1] + q[i, j-1])
     elif i == Ny-1 :
       new_q[i, j] = 0.25 * (2*q[i-1, j] + z[i, j+1] + q[i, j-1])
     else:
       new_q[i, j] = 0.25 * (q[i+1, j] + q[i-1, j] + q[i, j+1] + q[i, j-1])
  q = np.copy(new_q)

plt.figure(1)
ho = plt.contourf(X, Y, q, cmap='hot')
cset = plt.contour(X,Y,q,np.arange(10,100,10),linewidths=2,cmap='gray_r')
plt.clabel(cset,inline=True,fmt='%1.2f',fontsize=10)
plt.colorbar(ho, label='Temperature (°C)')
plt.title('Problem 1')
plt.xlabel('X (centimeters)')
plt.ylabel('Y (centimeters)')
plt.show()
print("")

plt.figure(2)
im = plt.imshow(q[:,:],cmap='hot')
bset = plt.contour(q[:,:],np.arange(10,100,10),linewidths=2,cmap='gray_r')
plt.clabel(bset,inline=True,fmt='%1.2f',fontsize=10)
plt.colorbar(im)
plt.title('Problem 1')
plt.xlabel('X (Nodes)')
plt.ylabel('Y (Nodes)')
plt.show()
```

"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from matplotlib.animation import FuncAnimation

I = lambda k, Nx: k % Nx
J = lambda k, Nx: int(k/Nx)
IJ = lambda k, Nx: [I(k,Nx),J(k,Nx)]
k = lambda i, j, Nx: i + j*Nx

print("2D heat equation solver - small example")

Nx = 41
Ny = 51
Nxy = Nx*Ny

A = np.zeros((Nxy,Nxy))
b = np.zeros(Nxy)

x_plate_length = 0.1 # m
y_plate_length = 0.05 # m
dx = x_plate_length/(Nx-1)
dy = y_plate_length/(Ny-1)

# Heat flux BC values
K = 25.0   # W/m-K

# Boundary conditions
Bnodes_L = np.zeros(Ny,dtype=int)
Bnodes_R = np.zeros(Ny,dtype=int)
Bnodes_T = np.zeros(Nx,dtype=int)
Bnodes_B = np.zeros(Nx,dtype=int)

u_top = 100.0   # K
u_left = 0.0    # K
u_right = 100.0 # K

# Set the boundary conditions
for j in range(0, Ny,1):
    Bnodes_L[j] = k(0,j,Nx)
    b[Bnodes_L[j]] = u_left
for j in range(0, Ny,1):
    Bnodes_R[j] = k(Nx-1,j,Nx)
    b[Bnodes_R[j]] = u_right
for i in range(1, Nx-1,1):
    Bnodes_T[i] = k(i,Ny-1,Nx)
    b[Bnodes_T[i]] = u_top

# Set zero heat flux boundary nodes
for i in range(1,Nx-1,1):
    Bnodes_B[i] = k(i,0,Nx)

def calculate():

    for i in range(0,Nx,1):
        for j in range(0,Ny,1):

            ij = k(i,j,Nx)  # k index for node i,j
            ip1j = k(i+1,j,Nx)
            im1j = k(i-1,j,Nx)
            ijp1 = k(i,j+1,Nx)
            ijm1 = k(i,j-1,Nx)

            if ij in Bnodes_L or ij in Bnodes_R or ij in Bnodes_T or ij in Bnodes_B:
                A[ij,ij] = 1.
            else:
                A[ij,ij] = -2.*(1./dx**2 + 1./dy**2)
                A[ij,ip1j] = 1./dx**2
                A[ij,im1j] = 1./dx**2
                A[ij,ijp1] = 1./dy**2
                A[ij,ijm1] = 1./dy**2

    # Apply insulated bottom BC
    for i in range(1,Nx-1,1):
        j = 0

        ij = k(i,j,Nx)  # k index for node i,j
        ip1j = k(i+1,j,Nx)
        im1j = k(i-1,j,Nx)
        ijp1 = k(i,j+1,Nx)
        ijm1 = k(i,j-1,Nx)

        A[ij,ij] = -2.*(1./dx**2 + 1./dy**2)
        A[ij,ip1j] = 1./dx**2
        A[ij,im1j] = 1./dx**2
        A[ij,ijp1] = 2./dy**2
        b[ij] = 0.0

    x = np.linalg.solve(A, b)

    #print('x = ', x)

    sol = np.zeros((Ny,Nx))
    for kk in range(0,Nxy,1):
        i = I(kk,Nx)
        j = J(kk,Nx)
        sol[j,i] = x[kk]

    #print('sol = ', sol)

    return sol

# Do the calculation here
u = calculate()

#im = plt.imshow(u[:,:],cmap=plt.cm.RdBu,extent=(0,Nx, 0., Ny),origin='lower')
im = plt.imshow(u[:,:],cmap=plt.cm.RdBu_r,extent=(0,Nx-1, 0., Ny-1),origin='lower',aspect='equal')

# adding the Contour lines with labels
cset = plt.contour(u[:,:],np.arange(10.,300.,10.),linewidths=2,cmap=plt.cm.Set2)
plt.clabel(cset,inline=True,fmt='%1.1f',fontsize=10)
plt.colorbar(im) # adding the colobar on the right
# latex fashion title
plt.title(f'$u(x,y)$')
name = "u.pdf"
plt.savefig(name, format="pdf", bbox_inches="tight")
plt.show()

print("Done!")

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from matplotlib.animation import FuncAnimation

I = lambda k, Nx: k % Nx
J = lambda k, Nx: int(k/Nx)
IJ = lambda k, Nx: [I(k,Nx),J(k,Nx)]
k = lambda i, j, Nx: i + j*Nx

print("2D heat equation solver - small example")

Nx = 41
Ny = 51
Nxy = Nx*Ny

A = np.zeros((Nxy,Nxy))
b = np.zeros(Nxy)

x_plate_length = 0.2 # m
y_plate_length = 0.3 # m
dx = x_plate_length/(Nx-1)
dy = y_plate_length/(Ny-1)

# Heat flux BC values
K = 25.0   # W/m-K

# Boundary conditions
Bnodes_L = np.zeros(Ny,dtype=int)
Bnodes_R = np.zeros(Ny,dtype=int)
Bnodes_T = np.zeros(Nx,dtype=int)
Bnodes_B = np.zeros(Nx,dtype=int)


u_left = 0.0    # K
u_right = 100.0 # K

# Set the boundary conditions
for j in range(0, Ny,1):
    Bnodes_L[j] = k(0,j,Nx)
    b[Bnodes_L[j]] = u_left
for j in range(0, Ny,1):
    Bnodes_R[j] = k(Nx-1,j,Nx)
    b[Bnodes_R[j]] = u_right


# Set zero heat flux boundary nodes
for i in range(1,Nx-1,1):
    Bnodes_B[i] = k(i,0,Nx)
for i in range(1, Nx-1,1):
    Bnodes_T[i] = k(i,Ny-1,Nx)

def calculate():

    for i in range(0,Nx,1):
        for j in range(0,Ny,1):

            ij = k(i,j,Nx)  # k index for node i,j
            ip1j = k(i+1,j,Nx)
            im1j = k(i-1,j,Nx)
            ijp1 = k(i,j+1,Nx)
            ijm1 = k(i,j-1,Nx)

            if ij in Bnodes_L or ij in Bnodes_R or ij in Bnodes_T or ij in Bnodes_B:
                A[ij,ij] = 1.
            else:
                A[ij,ij] = -2.*(1./dx**2 + 1./dy**2)
                A[ij,ip1j] = 1./dx**2
                A[ij,im1j] = 1./dx**2
                A[ij,ijp1] = 1./dy**2
                A[ij,ijm1] = 1./dy**2

    # Apply insulated bottom BC
    for i in range(1,Nx-1,1):
        j = 0

        ij = k(i,j,Nx)  # k index for node i,j
        ip1j = k(i+1,j,Nx)
        im1j = k(i-1,j,Nx)
        ijp1 = k(i,j+1,Nx)
        ijm1 = k(i,j-1,Nx)

        A[ij,ij] = -2.*(1./dx**2 + 1./dy**2)
        A[ij,ip1j] = 1./dx**2
        A[ij,im1j] = 1./dx**2
        A[ij,ijp1] = 2./dy**2
        b[ij] = 0.0

    for i in range(1,0,1):
        j = 0

        ij = k(i,j,Nx)  # k index for node i,j
        ip1j = k(i+1,j,Nx)
        im1j = k(i-1,j,Nx)
        ijp1 = k(i,j+1,Nx)
        ijm1 = k(i,j-1,Nx)

        A[ij,ij] = -2.*(1./dx**2 + 1./dy**2)
        A[ij,ip1j] = 1./dx**2
        A[ij,im1j] = 1./dx**2
        A[ij,ijp1] = 2./dy**2
        b[ij] = 0.0

    x = np.linalg.solve(A, b)

    #print('x = ', x)

    sol = np.zeros((Ny,Nx))
    for kk in range(0,Nxy,1):
        i = I(kk,Nx)
        j = J(kk,Nx)
        sol[j,i] = x[kk]

    #print('sol = ', sol)

    return sol

# Do the calculation here
u = calculate()

#im = plt.imshow(u[:,:],cmap=plt.cm.RdBu,extent=(0,Nx, 0., Ny),origin='lower')
im = plt.imshow(u[:,:],cmap=plt.cm.RdBu_r,extent=(0,Nx-1, 0., Ny-1),origin='lower',aspect='equal')

# adding the Contour lines with labels
cset = plt.contour(u[:,:],np.arange(10.,300.,10.),linewidths=2,cmap=plt.cm.Set2)
plt.clabel(cset,inline=True,fmt='%1.1f',fontsize=10)
plt.colorbar(im) # adding the colobar on the right
# latex fashion title
plt.title(f'$u(x,y)$')
name = "u.pdf"
plt.savefig(name, format="pdf", bbox_inches="tight")
plt.show()

print("Done!")